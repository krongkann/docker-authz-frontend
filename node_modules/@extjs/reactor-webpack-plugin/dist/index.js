'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _cjson = require('cjson');

var _cjson2 = _interopRequireDefault(_cjson);

var _mkdirp = require('mkdirp');

var _extractFromJSX = require('./extractFromJSX');

var _extractFromJSX2 = _interopRequireDefault(_extractFromJSX);

var _rimraf = require('rimraf');

var _artifacts = require('./artifacts');

var _child_process = require('child_process');

var _astring = require('astring');

var _resolve = require('resolve');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var watching = false;
var cmdErrors = void 0;

/**
 * Scrapes Sencha Cmd output, adding error messages to cmdErrors;
 * @param {Process} build A sencha Cmd process
 */
var gatherErrors = function gatherErrors(cmd) {
    cmd.stdout.on('data', function (data) {
        var message = data.toString();

        if (message.match(/^\[ERR\]/)) {
            cmdErrors.push(message.replace(/^\[ERR\] /gi, ''));
        }
    });

    return cmd;
};

/**
 * Produces a minimal build of ExtReact by crawling your React source code and extracting the xtypes used
 * in JSX tags
 */
module.exports = function () {

    /**
     * @param {Object[]} builds
     * @param {Boolean} [debug=false] Set to true to prevent cleanup of build temporary build artifacts that might be helpful in troubleshooting issues.
     * @param {String} sdk The full path to the ExtReact SDK
     * @param {String} [toolkit='modern'] "modern" or "classic"
     * @param {String} theme The name of the ExtReact theme package to use, for example "theme-material"
     * @param {String[]} packages An array of ExtReact packages to include
     * @param {String[]} overrides An array with the paths of directories or files to search. Any classes
     * declared in these locations will be automatically required and included in the build.
     * If any file defines an ExtReact override (using Ext.define with an "override" property),
     * that override will in fact only be included in the build if the target class specified
     * in the "override" property is also included.
     * @param {String} output The path to directory where the ExtReact bundle should be written
     * @param {Boolean} asynchronous Set to true to run Sencha Cmd builds asynchronously. This makes the webpack build finish much faster, but the app may not load correctly in your browser until Sencha Cmd is finished building the ExtReact bundle
     * @param {Boolean} production Set to true for production builds.  This tell Sencha Cmd to compress the generated JS bundle.
     * @param {Boolean} treeShaking Set to false to disable tree shaking in development builds.  This makes incremental rebuilds faster as all ExtReact components are included in the ext.js bundle in the initial build and thus the bundle does not need to be rebuilt after each change. Defaults to true.
     */
    function ReactExtJSWebpackPlugin(options) {
        _classCallCheck(this, ReactExtJSWebpackPlugin);

        // if .ext-reactrc file exists, consume it and apply it to config options.
        var extReactRc = _fs2.default.existsSync('.ext-reactrc') && JSON.parse(_fs2.default.readFileSync('.ext-reactrc', 'utf-8')) || {};

        options = _extends({}, this.getDefaultOptions(), options, extReactRc);
        var _options = options,
            builds = _options.builds;


        if (Object.keys(builds).length === 0) {
            var _options2 = options,
                _builds = _options2.builds,
                buildOptions = _objectWithoutProperties(_options2, ['builds']);

            _builds.ext = buildOptions;
        }

        for (var name in builds) {
            this._validateBuildConfig(name, builds[name]);
        }Object.assign(this, _extends({}, options, {
            currentFile: null,
            manifest: null,
            dependencies: []
        }));
    }

    /**
     * Default config options
     * @protected
     * @return {Object}
     */


    _createClass(ReactExtJSWebpackPlugin, [{
        key: 'getDefaultOptions',
        value: function getDefaultOptions() {
            return {
                builds: {},
                debug: false,
                watch: false,
                test: /\.(j|t)sx?$/,

                /* begin single build only */
                output: 'ext-react',
                toolkit: 'modern',
                packages: null,
                packageDirs: [],
                overrides: [],
                asynchronous: false,
                production: false,
                manifestExtractor: _extractFromJSX2.default,
                treeShaking: true
                /* end single build only */
            };
        }
    }, {
        key: 'apply',
        value: function apply(compiler) {
            var _this = this;

            var me = this;

            /**
             * Adds the code for the specified function call to the manifest.js file
             * @param {Object} call A function call AST node.
             */
            var addToManifest = function addToManifest(call) {
                try {
                    var _file = this.state.module.resource;
                    me.dependencies[_file] = [].concat(_toConsumableArray(me.dependencies[_file] || []), [(0, _astring.generate)(call)]);
                } catch (e) {
                    console.error('Error processing ' + file);
                }
            };

            compiler.plugin('watch-run', function (watching, cb) {
                _this.watch = true;
                cb();
            });

            // extract xtypes from JSX tags
            compiler.plugin('compilation', function (compilation, data) {
                compilation.plugin('succeed-module', function (module) {
                    _this.currentFile = module.resource;

                    if (module.resource && module.resource.match(_this.test) && !module.resource.match(/node_modules/)) {
                        var doParse = function doParse() {
                            _this.dependencies[_this.currentFile] = [].concat(_toConsumableArray(_this.dependencies[_this.currentFile] || []), _toConsumableArray(_this.manifestExtractor(module._source._value, compilation, module)));
                        };

                        if (_this.debug) {
                            doParse();
                        } else {
                            try {
                                doParse();
                            } catch (e) {
                                console.error('error parsing ' + _this.currentFile);
                            }
                        }
                    }
                });

                data.normalModuleFactory.plugin("parser", function (parser, options) {
                    // extract xtypes and classes from Ext.create calls
                    parser.plugin('call Ext.create', addToManifest);

                    // copy Ext.require calls to the manifest.  This allows the users to explicitly require a class if the plugin fails to detect it.
                    parser.plugin('call Ext.require', addToManifest);

                    // copy Ext.define calls to the manifest.  This allows users to write standard ExtReact classes.
                    parser.plugin('call Ext.define', addToManifest);
                });
            });

            // once all modules are processed, create the optimized ExtReact build.
            compiler.plugin('emit', function (compilation, callback) {
                var modules = compilation.chunks.reduce(function (a, b) {
                    return a.concat(b.modules);
                }, []);
                var build = _this.builds[Object.keys(_this.builds)[0]];

                var outputPath = _path2.default.join(compiler.outputPath, _this.output);

                // webpack-dev-server overwrites the outputPath to "/", so we need to prepend contentBase
                if (compiler.outputPath === '/' && compiler.options.devServer) {
                    outputPath = _path2.default.join(compiler.options.devServer.contentBase, outputPath);
                }

                // the following is needed for html-webpack-plugin to include <script> and <link> tags for ExtReact
                var jsChunk = compilation.addChunk(_this.output + '-js');

                jsChunk.hasRuntime = jsChunk.isInitial = function () {
                    return true;
                };
                jsChunk.files.push(_path2.default.join(_this.output, 'ext.js'));
                jsChunk.files.push(_path2.default.join(_this.output, 'ext.css'));
                jsChunk.id = -2; // this forces html-webpack-plugin to include ext.js first

                if (_this.asynchronous) callback();

                _this._buildExtBundle('ext', modules, outputPath, build).then(function () {
                    // const cssVarPath = path.join(this.output, 'css-vars.js');

                    // if (fs.existsSync(path.join(outputPath, 'css-vars.js'))) {
                    //     const cssVarChunk = compilation.addChunk(`${this.output}-css-vars`);
                    //     cssVarChunk.hasRuntime = cssVarChunk.isInitial = () => true;
                    //     cssVarChunk.files.push(cssVarPath);
                    //     cssVarChunk.id = -1;
                    // }
                    !_this.asynchronous && callback();
                }).catch(function (e) {
                    compilation.errors.push(new Error('[@extjs/reactor-webpack-plugin]: ' + e.toString()));
                    !_this.asynchronous && callback();
                });
            });
        }

        /**
         * Checks each build config for missing/invalid properties
         * @param {String} name The name of the build
         * @param {String} build The build config
         * @private
         */

    }, {
        key: '_validateBuildConfig',
        value: function _validateBuildConfig(name, build) {
            var sdk = build.sdk,
                production = build.production;


            if (production) {
                build.treeShaking = true;
            }

            if (sdk) {
                if (!_fs2.default.existsSync(sdk)) {
                    throw new Error('No SDK found at ' + _path2.default.resolve(sdk) + '.  Did you for get to link/copy your Ext JS SDK to that location?');
                } else {
                    this._addReactorPackage(build);
                }
            } else {
                try {
                    build.sdk = _path2.default.dirname((0, _resolve.sync)('@extjs/ext-react', { basedir: process.cwd() }));
                    build.packageDirs = [].concat(_toConsumableArray(build.packageDirs || []), [_path2.default.dirname(build.sdk)]);
                    build.packages = build.packages || this._findPackages(build.sdk);
                } catch (e) {
                    throw new Error('@extjs/ext-react not found.  You can install it with "npm install --save @extjs/ext-react" or, if you have a local copy of the SDK, specify the path to it using the "sdk" option in build "' + name + '."');
                }
            }
        }

        /**
         * Adds the reactor package if present and the toolkit is modern
         * @param {Object} build 
         */

    }, {
        key: '_addReactorPackage',
        value: function _addReactorPackage(build) {
            if (build.toolkit === 'classic') return;

            if (_fs2.default.existsSync(_path2.default.join(build.sdk, 'ext', 'modern', 'reactor')) || // repo
            _fs2.default.existsSync(_path2.default.join(build.sdk, 'modern', 'reactor'))) {
                // production build

                if (!build.packages) {
                    build.packages = [];
                }

                build.packages.push('reactor');
            }
        }

        /**
         * Return the names of all ExtReact packages in the same parent directory as ext-react (typically node_modules/@extjs)
         * @private
         * @param {String} sdk Path to ext-react
         * @return {String[]}
         */

    }, {
        key: '_findPackages',
        value: function _findPackages(sdk) {
            var modulesDir = _path2.default.join(sdk, '..');

            return _fs2.default.readdirSync(modulesDir)
            // Filter out directories without 'package.json'
            .filter(function (dir) {
                return _fs2.default.existsSync(_path2.default.join(modulesDir, dir, 'package.json'));
            })
            // Generate array of package names
            .map(function (dir) {
                var packageInfo = JSON.parse(_fs2.default.readFileSync(_path2.default.join(modulesDir, dir, 'package.json')));
                // Don't include theme type packages.
                if (packageInfo.sencha && packageInfo.sencha.type !== 'theme') {
                    return packageInfo.sencha.name;
                }
            })
            // Remove any undefineds from map
            .filter(function (name) {
                return name;
            });
        }

        /**
         * Returns the path to the sencha cmd executable
         * @private
         * @return {String}
         */

    }, {
        key: '_getSenchCmdPath',
        value: function _getSenchCmdPath() {
            try {
                // use @extjs/sencha-cmd from node_modules
                return require('@extjs/sencha-cmd');
            } catch (e) {
                // attempt to use globally installed Sencha Cmd
                return 'sencha';
            }
        }

        /**
         /**
         * Builds a minimal version of the ExtReact framework based on the classes used
         * @param {String} name The name of the build
         * @param {Module[]} modules webpack modules
         * @param {String} output The path to where the framework build should be written
         * @param {String} [toolkit='modern'] "modern" or "classic"
         * @param {String} output The path to the directory to create which will contain the js and css bundles
         * @param {String} theme The name of the ExtReact theme package to use, for example "theme-material"
         * @param {String[]} packages An array of ExtReact packages to include
         * @param {String[]} packageDirs Directories containing packages
         * @param {String[]} overrides An array of locations for overrides
         * @param {String} sdk The full path to the ExtReact SDK
         * @private
         */

    }, {
        key: '_buildExtBundle',
        value: function _buildExtBundle(name, modules, output, _ref) {
            var _this2 = this;

            var _ref$toolkit = _ref.toolkit,
                toolkit = _ref$toolkit === undefined ? 'modern' : _ref$toolkit,
                theme = _ref.theme,
                _ref$packages = _ref.packages,
                packages = _ref$packages === undefined ? [] : _ref$packages,
                _ref$packageDirs = _ref.packageDirs,
                packageDirs = _ref$packageDirs === undefined ? [] : _ref$packageDirs,
                sdk = _ref.sdk,
                overrides = _ref.overrides;

            var sencha = this._getSenchCmdPath();

            theme = theme || (toolkit === 'classic' ? 'theme-triton' : 'theme-material');

            return new Promise(function (resolve, reject) {
                _this2.onBuildFail = reject;
                _this2.onBuildSuccess = resolve;

                cmdErrors = [];

                var onBuildDone = function onBuildDone() {
                    if (cmdErrors.length) {
                        _this2.onBuildFail(new Error(cmdErrors.join("")));
                    } else {
                        _this2.onBuildSuccess();
                    }
                };

                if (!watching) {
                    (0, _rimraf.sync)(output);
                    (0, _mkdirp.sync)(output);
                }

                var js = void 0;

                if (_this2.treeShaking) {
                    var statements = ['Ext.require(["Ext.app.Application", "Ext.Component", "Ext.Widget"])']; // for some reason command doesn't load component when only panel is required

                    if (packages.indexOf('reactor') !== -1) {
                        statements.push('Ext.require("Ext.reactor.RendererCell")');
                    }

                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = undefined;

                    try {
                        for (var _iterator = modules[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                            var _module = _step.value;

                            var deps = _this2.dependencies[_module.resource];
                            if (deps) statements = statements.concat(deps);
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return) {
                                _iterator.return();
                            }
                        } finally {
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }

                    js = statements.join(';\n');
                } else {
                    js = 'Ext.require("Ext.*")';
                }

                var manifest = _path2.default.join(output, 'manifest.js');

                // add ext-react/packages automatically if present
                var userPackages = _path2.default.join('.', 'ext-react', 'packages');

                if (_fs2.default.existsSync(userPackages)) {
                    packageDirs.push(userPackages);
                }

                if (_fs2.default.existsSync(_path2.default.join(sdk, 'ext'))) {
                    // local checkout of the SDK repo
                    packageDirs.push(_path2.default.join('ext', 'packages'));
                    sdk = _path2.default.join(sdk, 'ext');
                }

                if (!watching) {
                    _fs2.default.writeFileSync(_path2.default.join(output, 'build.xml'), (0, _artifacts.buildXML)({ compress: _this2.production }), 'utf8');
                    _fs2.default.writeFileSync(_path2.default.join(output, 'jsdom-environment.js'), (0, _artifacts.createJSDOMEnvironment)(), 'utf8');
                    _fs2.default.writeFileSync(_path2.default.join(output, 'app.json'), (0, _artifacts.createAppJson)({ theme: theme, packages: packages, toolkit: toolkit, overrides: overrides, packageDirs: packageDirs }), 'utf8');
                    _fs2.default.writeFileSync(_path2.default.join(output, 'workspace.json'), (0, _artifacts.createWorkspaceJson)(sdk, packageDirs, output), 'utf8');
                }

                var cmdRebuildNeeded = false;

                if (_this2.manifest === null || js !== _this2.manifest) {
                    // Only write manifest if it differs from the last run.  This prevents unnecessary cmd rebuilds.
                    _this2.manifest = js;
                    _fs2.default.writeFileSync(manifest, js, 'utf8');
                    cmdRebuildNeeded = true;
                    console.log('\nbuilding ExtReact bundle: ' + name + ' => ' + output);
                }

                if (_this2.watch) {
                    if (!watching) {
                        watching = gatherErrors((0, _child_process.fork)(sencha, ['ant', 'watch'], { cwd: output, silent: true }));
                        watching.stderr.pipe(process.stderr);
                        watching.stdout.pipe(process.stdout);
                        watching.stdout.on('data', function (data) {
                            if (data && data.toString().match(/Waiting for changes\.\.\./)) {
                                onBuildDone();
                            }
                        });
                        watching.on('exit', onBuildDone);
                    }

                    if (!cmdRebuildNeeded) onBuildDone();
                } else {
                    var build = gatherErrors((0, _child_process.fork)(sencha, ['ant', 'build'], { cwd: output, silent: true }));
                    build.stdout.pipe(process.stdout);
                    build.stderr.pipe(process.stderr);
                    build.on('exit', onBuildDone);
                }
            });
        }
    }]);

    return ReactExtJSWebpackPlugin;
}();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJ3YXRjaGluZyIsImNtZEVycm9ycyIsImdhdGhlckVycm9ycyIsImNtZCIsInN0ZG91dCIsIm9uIiwibWVzc2FnZSIsImRhdGEiLCJ0b1N0cmluZyIsIm1hdGNoIiwicHVzaCIsInJlcGxhY2UiLCJtb2R1bGUiLCJleHBvcnRzIiwib3B0aW9ucyIsImV4dFJlYWN0UmMiLCJleGlzdHNTeW5jIiwiSlNPTiIsInBhcnNlIiwicmVhZEZpbGVTeW5jIiwiZ2V0RGVmYXVsdE9wdGlvbnMiLCJidWlsZHMiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwiYnVpbGRPcHRpb25zIiwiZXh0IiwibmFtZSIsIl92YWxpZGF0ZUJ1aWxkQ29uZmlnIiwiYXNzaWduIiwiY3VycmVudEZpbGUiLCJtYW5pZmVzdCIsImRlcGVuZGVuY2llcyIsImRlYnVnIiwid2F0Y2giLCJ0ZXN0Iiwib3V0cHV0IiwidG9vbGtpdCIsInBhY2thZ2VzIiwicGFja2FnZURpcnMiLCJvdmVycmlkZXMiLCJhc3luY2hyb25vdXMiLCJwcm9kdWN0aW9uIiwibWFuaWZlc3RFeHRyYWN0b3IiLCJ0cmVlU2hha2luZyIsImNvbXBpbGVyIiwibWUiLCJhZGRUb01hbmlmZXN0IiwiY2FsbCIsImZpbGUiLCJzdGF0ZSIsInJlc291cmNlIiwiZSIsImNvbnNvbGUiLCJlcnJvciIsInBsdWdpbiIsImNiIiwiY29tcGlsYXRpb24iLCJkb1BhcnNlIiwiX3NvdXJjZSIsIl92YWx1ZSIsIm5vcm1hbE1vZHVsZUZhY3RvcnkiLCJwYXJzZXIiLCJjYWxsYmFjayIsIm1vZHVsZXMiLCJjaHVua3MiLCJyZWR1Y2UiLCJhIiwiYiIsImNvbmNhdCIsImJ1aWxkIiwib3V0cHV0UGF0aCIsImpvaW4iLCJkZXZTZXJ2ZXIiLCJjb250ZW50QmFzZSIsImpzQ2h1bmsiLCJhZGRDaHVuayIsImhhc1J1bnRpbWUiLCJpc0luaXRpYWwiLCJmaWxlcyIsImlkIiwiX2J1aWxkRXh0QnVuZGxlIiwidGhlbiIsImNhdGNoIiwiZXJyb3JzIiwiRXJyb3IiLCJzZGsiLCJyZXNvbHZlIiwiX2FkZFJlYWN0b3JQYWNrYWdlIiwiZGlybmFtZSIsImJhc2VkaXIiLCJwcm9jZXNzIiwiY3dkIiwiX2ZpbmRQYWNrYWdlcyIsIm1vZHVsZXNEaXIiLCJyZWFkZGlyU3luYyIsImZpbHRlciIsImRpciIsIm1hcCIsInBhY2thZ2VJbmZvIiwic2VuY2hhIiwidHlwZSIsInJlcXVpcmUiLCJ0aGVtZSIsIl9nZXRTZW5jaENtZFBhdGgiLCJQcm9taXNlIiwicmVqZWN0Iiwib25CdWlsZEZhaWwiLCJvbkJ1aWxkU3VjY2VzcyIsIm9uQnVpbGREb25lIiwianMiLCJzdGF0ZW1lbnRzIiwiaW5kZXhPZiIsImRlcHMiLCJ1c2VyUGFja2FnZXMiLCJ3cml0ZUZpbGVTeW5jIiwiY29tcHJlc3MiLCJjbWRSZWJ1aWxkTmVlZGVkIiwibG9nIiwic2lsZW50Iiwic3RkZXJyIiwicGlwZSJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUNBOzs7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7QUFFQSxJQUFJQSxXQUFXLEtBQWY7QUFDQSxJQUFJQyxrQkFBSjs7QUFFQTs7OztBQUlBLElBQU1DLGVBQWUsU0FBZkEsWUFBZSxDQUFDQyxHQUFELEVBQVM7QUFDMUJBLFFBQUlDLE1BQUosQ0FBV0MsRUFBWCxDQUFjLE1BQWQsRUFBc0IsZ0JBQVE7QUFDMUIsWUFBTUMsVUFBVUMsS0FBS0MsUUFBTCxFQUFoQjs7QUFFQSxZQUFJRixRQUFRRyxLQUFSLENBQWMsVUFBZCxDQUFKLEVBQStCO0FBQzNCUixzQkFBVVMsSUFBVixDQUFlSixRQUFRSyxPQUFSLENBQWdCLGFBQWhCLEVBQStCLEVBQS9CLENBQWY7QUFDSDtBQUNKLEtBTkQ7O0FBUUEsV0FBT1IsR0FBUDtBQUNILENBVkQ7O0FBWUE7Ozs7QUFJQVMsT0FBT0MsT0FBUDs7QUFFSTs7Ozs7Ozs7Ozs7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LElBQWIsQ0FBa0I5QixRQUFRNkIsTUFBMUI7QUFDQWxELDBCQUFNakUsRUFBTixDQUFTLE1BQVQsRUFBaUJ3RyxXQUFqQjtBQUNIO0FBQ0osYUExRk0sQ0FBUDtBQTJGSDtBQTFXTDs7QUFBQTtBQUFBIiwiZmlsZSI6ImluZGV4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgY2pzb24gZnJvbSAnY2pzb24nO1xuaW1wb3J0IHsgc3luYyBhcyBta2RpcnAgfSBmcm9tICdta2RpcnAnO1xuaW1wb3J0IGV4dHJhY3RGcm9tSlNYIGZyb20gJy4vZXh0cmFjdEZyb21KU1gnO1xuaW1wb3J0IHsgc3luYyBhcyByaW1yYWYgfSBmcm9tICdyaW1yYWYnO1xuaW1wb3J0IHsgYnVpbGRYTUwsIGNyZWF0ZUFwcEpzb24sIGNyZWF0ZVdvcmtzcGFjZUpzb24sIGNyZWF0ZUpTRE9NRW52aXJvbm1lbnQgfSBmcm9tICcuL2FydGlmYWN0cyc7XG5pbXBvcnQgeyBleGVjU3luYywgc3Bhd24sIGZvcmsgfSBmcm9tICdjaGlsZF9wcm9jZXNzJztcbmltcG9ydCB7IGdlbmVyYXRlIH0gZnJvbSAnYXN0cmluZyc7XG5pbXBvcnQgeyBzeW5jIGFzIHJlc29sdmUgfSBmcm9tICdyZXNvbHZlJztcblxubGV0IHdhdGNoaW5nID0gZmFsc2U7XG5sZXQgY21kRXJyb3JzO1xuXG4vKipcbiAqIFNjcmFwZXMgU2VuY2hhIENtZCBvdXRwdXQsIGFkZGluZyBlcnJvciBtZXNzYWdlcyB0byBjbWRFcnJvcnM7XG4gKiBAcGFyYW0ge1Byb2Nlc3N9IGJ1aWxkIEEgc2VuY2hhIENtZCBwcm9jZXNzXG4gKi9cbmNvbnN0IGdhdGhlckVycm9ycyA9IChjbWQpID0+IHtcbiAgICBjbWQuc3Rkb3V0Lm9uKCdkYXRhJywgZGF0YSA9PiB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBkYXRhLnRvU3RyaW5nKCk7XG4gICAgICAgIFxuICAgICAgICBpZiAobWVzc2FnZS5tYXRjaCgvXlxcW0VSUlxcXS8pKSB7XG4gICAgICAgICAgICBjbWRFcnJvcnMucHVzaChtZXNzYWdlLnJlcGxhY2UoL15cXFtFUlJcXF0gL2dpLCAnJykpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY21kO1xufVxuXG4vKipcbiAqIFByb2R1Y2VzIGEgbWluaW1hbCBidWlsZCBvZiBFeHRSZWFjdCBieSBjcmF3bGluZyB5b3VyIFJlYWN0IHNvdXJjZSBjb2RlIGFuZCBleHRyYWN0aW5nIHRoZSB4dHlwZXMgdXNlZFxuICogaW4gSlNYIHRhZ3NcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBSZWFjdEV4dEpTV2VicGFja1BsdWdpbiB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBidWlsZHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtkZWJ1Zz1mYWxzZV0gU2V0IHRvIHRydWUgdG8gcHJldmVudCBjbGVhbnVwIG9mIGJ1aWxkIHRlbXBvcmFyeSBidWlsZCBhcnRpZmFjdHMgdGhhdCBtaWdodCBiZSBoZWxwZnVsIGluIHRyb3VibGVzaG9vdGluZyBpc3N1ZXMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNkayBUaGUgZnVsbCBwYXRoIHRvIHRoZSBFeHRSZWFjdCBTREtcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3Rvb2xraXQ9J21vZGVybiddIFwibW9kZXJuXCIgb3IgXCJjbGFzc2ljXCJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGhlbWUgVGhlIG5hbWUgb2YgdGhlIEV4dFJlYWN0IHRoZW1lIHBhY2thZ2UgdG8gdXNlLCBmb3IgZXhhbXBsZSBcInRoZW1lLW1hdGVyaWFsXCJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBwYWNrYWdlcyBBbiBhcnJheSBvZiBFeHRSZWFjdCBwYWNrYWdlcyB0byBpbmNsdWRlXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gb3ZlcnJpZGVzIEFuIGFycmF5IHdpdGggdGhlIHBhdGhzIG9mIGRpcmVjdG9yaWVzIG9yIGZpbGVzIHRvIHNlYXJjaC4gQW55IGNsYXNzZXNcbiAgICAgKiBkZWNsYXJlZCBpbiB0aGVzZSBsb2NhdGlvbnMgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHJlcXVpcmVkIGFuZCBpbmNsdWRlZCBpbiB0aGUgYnVpbGQuXG4gICAgICogSWYgYW55IGZpbGUgZGVmaW5lcyBhbiBFeHRSZWFjdCBvdmVycmlkZSAodXNpbmcgRXh0LmRlZmluZSB3aXRoIGFuIFwib3ZlcnJpZGVcIiBwcm9wZXJ0eSksXG4gICAgICogdGhhdCBvdmVycmlkZSB3aWxsIGluIGZhY3Qgb25seSBiZSBpbmNsdWRlZCBpbiB0aGUgYnVpbGQgaWYgdGhlIHRhcmdldCBjbGFzcyBzcGVjaWZpZWRcbiAgICAgKiBpbiB0aGUgXCJvdmVycmlkZVwiIHByb3BlcnR5IGlzIGFsc28gaW5jbHVkZWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG91dHB1dCBUaGUgcGF0aCB0byBkaXJlY3Rvcnkgd2hlcmUgdGhlIEV4dFJlYWN0IGJ1bmRsZSBzaG91bGQgYmUgd3JpdHRlblxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gYXN5bmNocm9ub3VzIFNldCB0byB0cnVlIHRvIHJ1biBTZW5jaGEgQ21kIGJ1aWxkcyBhc3luY2hyb25vdXNseS4gVGhpcyBtYWtlcyB0aGUgd2VicGFjayBidWlsZCBmaW5pc2ggbXVjaCBmYXN0ZXIsIGJ1dCB0aGUgYXBwIG1heSBub3QgbG9hZCBjb3JyZWN0bHkgaW4geW91ciBicm93c2VyIHVudGlsIFNlbmNoYSBDbWQgaXMgZmluaXNoZWQgYnVpbGRpbmcgdGhlIEV4dFJlYWN0IGJ1bmRsZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcHJvZHVjdGlvbiBTZXQgdG8gdHJ1ZSBmb3IgcHJvZHVjdGlvbiBidWlsZHMuICBUaGlzIHRlbGwgU2VuY2hhIENtZCB0byBjb21wcmVzcyB0aGUgZ2VuZXJhdGVkIEpTIGJ1bmRsZS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHRyZWVTaGFraW5nIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIHRyZWUgc2hha2luZyBpbiBkZXZlbG9wbWVudCBidWlsZHMuICBUaGlzIG1ha2VzIGluY3JlbWVudGFsIHJlYnVpbGRzIGZhc3RlciBhcyBhbGwgRXh0UmVhY3QgY29tcG9uZW50cyBhcmUgaW5jbHVkZWQgaW4gdGhlIGV4dC5qcyBidW5kbGUgaW4gdGhlIGluaXRpYWwgYnVpbGQgYW5kIHRodXMgdGhlIGJ1bmRsZSBkb2VzIG5vdCBuZWVkIHRvIGJlIHJlYnVpbHQgYWZ0ZXIgZWFjaCBjaGFuZ2UuIERlZmF1bHRzIHRvIHRydWUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICAvLyBpZiAuZXh0LXJlYWN0cmMgZmlsZSBleGlzdHMsIGNvbnN1bWUgaXQgYW5kIGFwcGx5IGl0IHRvIGNvbmZpZyBvcHRpb25zLlxuICAgICAgICBjb25zdCBleHRSZWFjdFJjID0gKGZzLmV4aXN0c1N5bmMoJy5leHQtcmVhY3RyYycpICYmIEpTT04ucGFyc2UoZnMucmVhZEZpbGVTeW5jKCcuZXh0LXJlYWN0cmMnLCAndXRmLTgnKSkgfHwge30pO1xuXG4gICAgICAgIG9wdGlvbnMgPSB7IC4uLnRoaXMuZ2V0RGVmYXVsdE9wdGlvbnMoKSwgLi4ub3B0aW9ucywgLi4uZXh0UmVhY3RSYyB9O1xuICAgICAgICBjb25zdCB7IGJ1aWxkcyB9ID0gb3B0aW9ucztcblxuICAgICAgICBpZiAoT2JqZWN0LmtleXMoYnVpbGRzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHsgYnVpbGRzLCAuLi5idWlsZE9wdGlvbnMgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBidWlsZHMuZXh0ID0gYnVpbGRPcHRpb25zO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBidWlsZHMpXG4gICAgICAgICAgICB0aGlzLl92YWxpZGF0ZUJ1aWxkQ29uZmlnKG5hbWUsIGJ1aWxkc1tuYW1lXSk7XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgY3VycmVudEZpbGU6IG51bGwsXG4gICAgICAgICAgICBtYW5pZmVzdDogbnVsbCxcbiAgICAgICAgICAgIGRlcGVuZGVuY2llczogW11cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBjb25maWcgb3B0aW9uc1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0RGVmYXVsdE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBidWlsZHM6IHt9LFxuICAgICAgICAgICAgZGVidWc6IGZhbHNlLFxuICAgICAgICAgICAgd2F0Y2g6IGZhbHNlLFxuICAgICAgICAgICAgdGVzdDogL1xcLihqfHQpc3g/JC8sXG5cbiAgICAgICAgICAgIC8qIGJlZ2luIHNpbmdsZSBidWlsZCBvbmx5ICovXG4gICAgICAgICAgICBvdXRwdXQ6ICdleHQtcmVhY3QnLFxuICAgICAgICAgICAgdG9vbGtpdDogJ21vZGVybicsXG4gICAgICAgICAgICBwYWNrYWdlczogbnVsbCxcbiAgICAgICAgICAgIHBhY2thZ2VEaXJzOiBbXSxcbiAgICAgICAgICAgIG92ZXJyaWRlczogW10sXG4gICAgICAgICAgICBhc3luY2hyb25vdXM6IGZhbHNlLFxuICAgICAgICAgICAgcHJvZHVjdGlvbjogZmFsc2UsXG4gICAgICAgICAgICBtYW5pZmVzdEV4dHJhY3RvcjogZXh0cmFjdEZyb21KU1gsXG4gICAgICAgICAgICB0cmVlU2hha2luZzogdHJ1ZVxuICAgICAgICAgICAgLyogZW5kIHNpbmdsZSBidWlsZCBvbmx5ICovXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhcHBseShjb21waWxlcikge1xuXG4gICAgICAgIGNvbnN0IG1lID0gdGhpcztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyB0aGUgY29kZSBmb3IgdGhlIHNwZWNpZmllZCBmdW5jdGlvbiBjYWxsIHRvIHRoZSBtYW5pZmVzdC5qcyBmaWxlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYWxsIEEgZnVuY3Rpb24gY2FsbCBBU1Qgbm9kZS5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGFkZFRvTWFuaWZlc3QgPSBmdW5jdGlvbihjYWxsKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLnN0YXRlLm1vZHVsZS5yZXNvdXJjZTtcbiAgICAgICAgICAgICAgICBtZS5kZXBlbmRlbmNpZXNbZmlsZV0gPSBbIC4uLihtZS5kZXBlbmRlbmNpZXNbZmlsZV0gfHwgW10pLCBnZW5lcmF0ZShjYWxsKSBdO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHByb2Nlc3NpbmcgJHtmaWxlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbXBpbGVyLnBsdWdpbignd2F0Y2gtcnVuJywgKHdhdGNoaW5nLCBjYikgPT4ge1xuICAgICAgICAgICAgdGhpcy53YXRjaCA9IHRydWU7XG4gICAgICAgICAgICBjYigpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBleHRyYWN0IHh0eXBlcyBmcm9tIEpTWCB0YWdzXG4gICAgICAgIGNvbXBpbGVyLnBsdWdpbignY29tcGlsYXRpb24nLCAoY29tcGlsYXRpb24sIGRhdGEpID0+IHtcbiAgICAgICAgICAgIGNvbXBpbGF0aW9uLnBsdWdpbignc3VjY2VlZC1tb2R1bGUnLCAobW9kdWxlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50RmlsZSA9IG1vZHVsZS5yZXNvdXJjZTtcblxuICAgICAgICAgICAgICAgIGlmIChtb2R1bGUucmVzb3VyY2UgJiYgbW9kdWxlLnJlc291cmNlLm1hdGNoKHRoaXMudGVzdCkgJiYgIW1vZHVsZS5yZXNvdXJjZS5tYXRjaCgvbm9kZV9tb2R1bGVzLykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZG9QYXJzZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzW3RoaXMuY3VycmVudEZpbGVdID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLih0aGlzLmRlcGVuZGVuY2llc1t0aGlzLmN1cnJlbnRGaWxlXSB8fCBbXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4udGhpcy5tYW5pZmVzdEV4dHJhY3Rvcihtb2R1bGUuX3NvdXJjZS5fdmFsdWUsIGNvbXBpbGF0aW9uLCBtb2R1bGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb1BhcnNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkgeyBkb1BhcnNlKCk7IH0gY2F0Y2ggKGUpIHsgY29uc29sZS5lcnJvcignZXJyb3IgcGFyc2luZyAnICsgdGhpcy5jdXJyZW50RmlsZSk7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkYXRhLm5vcm1hbE1vZHVsZUZhY3RvcnkucGx1Z2luKFwicGFyc2VyXCIsIGZ1bmN0aW9uKHBhcnNlciwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIC8vIGV4dHJhY3QgeHR5cGVzIGFuZCBjbGFzc2VzIGZyb20gRXh0LmNyZWF0ZSBjYWxsc1xuICAgICAgICAgICAgICAgIHBhcnNlci5wbHVnaW4oJ2NhbGwgRXh0LmNyZWF0ZScsIGFkZFRvTWFuaWZlc3QpO1xuXG4gICAgICAgICAgICAgICAgLy8gY29weSBFeHQucmVxdWlyZSBjYWxscyB0byB0aGUgbWFuaWZlc3QuICBUaGlzIGFsbG93cyB0aGUgdXNlcnMgdG8gZXhwbGljaXRseSByZXF1aXJlIGEgY2xhc3MgaWYgdGhlIHBsdWdpbiBmYWlscyB0byBkZXRlY3QgaXQuXG4gICAgICAgICAgICAgICAgcGFyc2VyLnBsdWdpbignY2FsbCBFeHQucmVxdWlyZScsIGFkZFRvTWFuaWZlc3QpO1xuXG4gICAgICAgICAgICAgICAgLy8gY29weSBFeHQuZGVmaW5lIGNhbGxzIHRvIHRoZSBtYW5pZmVzdC4gIFRoaXMgYWxsb3dzIHVzZXJzIHRvIHdyaXRlIHN0YW5kYXJkIEV4dFJlYWN0IGNsYXNzZXMuXG4gICAgICAgICAgICAgICAgcGFyc2VyLnBsdWdpbignY2FsbCBFeHQuZGVmaW5lJywgYWRkVG9NYW5pZmVzdCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBvbmNlIGFsbCBtb2R1bGVzIGFyZSBwcm9jZXNzZWQsIGNyZWF0ZSB0aGUgb3B0aW1pemVkIEV4dFJlYWN0IGJ1aWxkLlxuICAgICAgICBjb21waWxlci5wbHVnaW4oJ2VtaXQnLCAoY29tcGlsYXRpb24sIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtb2R1bGVzID0gY29tcGlsYXRpb24uY2h1bmtzLnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYi5tb2R1bGVzKSwgW10pO1xuICAgICAgICAgICAgY29uc3QgYnVpbGQgPSB0aGlzLmJ1aWxkc1tPYmplY3Qua2V5cyh0aGlzLmJ1aWxkcylbMF1dO1xuXG4gICAgICAgICAgICBsZXQgb3V0cHV0UGF0aCA9IHBhdGguam9pbihjb21waWxlci5vdXRwdXRQYXRoLCB0aGlzLm91dHB1dCk7XG5cbiAgICAgICAgICAgIC8vIHdlYnBhY2stZGV2LXNlcnZlciBvdmVyd3JpdGVzIHRoZSBvdXRwdXRQYXRoIHRvIFwiL1wiLCBzbyB3ZSBuZWVkIHRvIHByZXBlbmQgY29udGVudEJhc2VcbiAgICAgICAgICAgIGlmIChjb21waWxlci5vdXRwdXRQYXRoID09PSAnLycgJiYgY29tcGlsZXIub3B0aW9ucy5kZXZTZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRQYXRoID0gcGF0aC5qb2luKGNvbXBpbGVyLm9wdGlvbnMuZGV2U2VydmVyLmNvbnRlbnRCYXNlLCBvdXRwdXRQYXRoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdGhlIGZvbGxvd2luZyBpcyBuZWVkZWQgZm9yIGh0bWwtd2VicGFjay1wbHVnaW4gdG8gaW5jbHVkZSA8c2NyaXB0PiBhbmQgPGxpbms+IHRhZ3MgZm9yIEV4dFJlYWN0XG4gICAgICAgICAgICBjb25zdCBqc0NodW5rID0gY29tcGlsYXRpb24uYWRkQ2h1bmsoYCR7dGhpcy5vdXRwdXR9LWpzYCk7XG5cbiAgICAgICAgICAgIGpzQ2h1bmsuaGFzUnVudGltZSA9IGpzQ2h1bmsuaXNJbml0aWFsID0gKCkgPT4gdHJ1ZTtcbiAgICAgICAgICAgIGpzQ2h1bmsuZmlsZXMucHVzaChwYXRoLmpvaW4odGhpcy5vdXRwdXQsICdleHQuanMnKSk7XG4gICAgICAgICAgICBqc0NodW5rLmZpbGVzLnB1c2gocGF0aC5qb2luKHRoaXMub3V0cHV0LCAnZXh0LmNzcycpKTtcbiAgICAgICAgICAgIGpzQ2h1bmsuaWQgPSAtMjsgLy8gdGhpcyBmb3JjZXMgaHRtbC13ZWJwYWNrLXBsdWdpbiB0byBpbmNsdWRlIGV4dC5qcyBmaXJzdFxuXG4gICAgICAgICAgICBpZiAodGhpcy5hc3luY2hyb25vdXMpIGNhbGxiYWNrKCk7XG5cbiAgICAgICAgICAgIHRoaXMuX2J1aWxkRXh0QnVuZGxlKCdleHQnLCBtb2R1bGVzLCBvdXRwdXRQYXRoLCBidWlsZClcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnN0IGNzc1ZhclBhdGggPSBwYXRoLmpvaW4odGhpcy5vdXRwdXQsICdjc3MtdmFycy5qcycpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIChmcy5leGlzdHNTeW5jKHBhdGguam9pbihvdXRwdXRQYXRoLCAnY3NzLXZhcnMuanMnKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIGNvbnN0IGNzc1ZhckNodW5rID0gY29tcGlsYXRpb24uYWRkQ2h1bmsoYCR7dGhpcy5vdXRwdXR9LWNzcy12YXJzYCk7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICBjc3NWYXJDaHVuay5oYXNSdW50aW1lID0gY3NzVmFyQ2h1bmsuaXNJbml0aWFsID0gKCkgPT4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIGNzc1ZhckNodW5rLmZpbGVzLnB1c2goY3NzVmFyUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICBjc3NWYXJDaHVuay5pZCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgICAgICF0aGlzLmFzeW5jaHJvbm91cyAmJiBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb21waWxhdGlvbi5lcnJvcnMucHVzaChuZXcgRXJyb3IoJ1tAZXh0anMvcmVhY3Rvci13ZWJwYWNrLXBsdWdpbl06ICcgKyBlLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgIXRoaXMuYXN5bmNocm9ub3VzICYmIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBlYWNoIGJ1aWxkIGNvbmZpZyBmb3IgbWlzc2luZy9pbnZhbGlkIHByb3BlcnRpZXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgYnVpbGRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYnVpbGQgVGhlIGJ1aWxkIGNvbmZpZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3ZhbGlkYXRlQnVpbGRDb25maWcobmFtZSwgYnVpbGQpIHtcbiAgICAgICAgbGV0IHsgc2RrLCBwcm9kdWN0aW9uIH0gPSBidWlsZDtcblxuICAgICAgICBpZiAocHJvZHVjdGlvbikge1xuICAgICAgICAgICAgYnVpbGQudHJlZVNoYWtpbmcgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNkaykge1xuICAgICAgICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKHNkaykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIFNESyBmb3VuZCBhdCAke3BhdGgucmVzb2x2ZShzZGspfS4gIERpZCB5b3UgZm9yIGdldCB0byBsaW5rL2NvcHkgeW91ciBFeHQgSlMgU0RLIHRvIHRoYXQgbG9jYXRpb24/YCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZFJlYWN0b3JQYWNrYWdlKGJ1aWxkKVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBidWlsZC5zZGsgPSBwYXRoLmRpcm5hbWUocmVzb2x2ZSgnQGV4dGpzL2V4dC1yZWFjdCcsIHsgYmFzZWRpcjogcHJvY2Vzcy5jd2QoKSB9KSlcbiAgICAgICAgICAgICAgICBidWlsZC5wYWNrYWdlRGlycyA9IFsuLi4oYnVpbGQucGFja2FnZURpcnMgfHwgW10pLCBwYXRoLmRpcm5hbWUoYnVpbGQuc2RrKV07XG4gICAgICAgICAgICAgICAgYnVpbGQucGFja2FnZXMgPSBidWlsZC5wYWNrYWdlcyB8fCB0aGlzLl9maW5kUGFja2FnZXMoYnVpbGQuc2RrKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEBleHRqcy9leHQtcmVhY3Qgbm90IGZvdW5kLiAgWW91IGNhbiBpbnN0YWxsIGl0IHdpdGggXCJucG0gaW5zdGFsbCAtLXNhdmUgQGV4dGpzL2V4dC1yZWFjdFwiIG9yLCBpZiB5b3UgaGF2ZSBhIGxvY2FsIGNvcHkgb2YgdGhlIFNESywgc3BlY2lmeSB0aGUgcGF0aCB0byBpdCB1c2luZyB0aGUgXCJzZGtcIiBvcHRpb24gaW4gYnVpbGQgXCIke25hbWV9LlwiYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSByZWFjdG9yIHBhY2thZ2UgaWYgcHJlc2VudCBhbmQgdGhlIHRvb2xraXQgaXMgbW9kZXJuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGJ1aWxkIFxuICAgICAqL1xuICAgIF9hZGRSZWFjdG9yUGFja2FnZShidWlsZCkge1xuICAgICAgICBpZiAoYnVpbGQudG9vbGtpdCA9PT0gJ2NsYXNzaWMnKSByZXR1cm47XG5cbiAgICAgICAgaWYgKGZzLmV4aXN0c1N5bmMocGF0aC5qb2luKGJ1aWxkLnNkaywgJ2V4dCcsICdtb2Rlcm4nLCAncmVhY3RvcicpKSB8fCAgLy8gcmVwb1xuICAgICAgICAgICAgZnMuZXhpc3RzU3luYyhwYXRoLmpvaW4oYnVpbGQuc2RrLCAnbW9kZXJuJywgJ3JlYWN0b3InKSkpIHsgLy8gcHJvZHVjdGlvbiBidWlsZFxuXG4gICAgICAgICAgICBpZiAoIWJ1aWxkLnBhY2thZ2VzKSB7XG4gICAgICAgICAgICAgICAgYnVpbGQucGFja2FnZXMgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnVpbGQucGFja2FnZXMucHVzaCgncmVhY3RvcicpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBuYW1lcyBvZiBhbGwgRXh0UmVhY3QgcGFja2FnZXMgaW4gdGhlIHNhbWUgcGFyZW50IGRpcmVjdG9yeSBhcyBleHQtcmVhY3QgKHR5cGljYWxseSBub2RlX21vZHVsZXMvQGV4dGpzKVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNkayBQYXRoIHRvIGV4dC1yZWFjdFxuICAgICAqIEByZXR1cm4ge1N0cmluZ1tdfVxuICAgICAqL1xuICAgIF9maW5kUGFja2FnZXMoc2RrKSB7XG4gICAgICAgIGNvbnN0IG1vZHVsZXNEaXIgPSBwYXRoLmpvaW4oc2RrLCAnLi4nKTtcbiAgICAgIFxuICAgICAgICByZXR1cm4gZnMucmVhZGRpclN5bmMobW9kdWxlc0RpcilcbiAgICAgICAgICAgIC8vIEZpbHRlciBvdXQgZGlyZWN0b3JpZXMgd2l0aG91dCAncGFja2FnZS5qc29uJ1xuICAgICAgICAgICAgLmZpbHRlcihkaXIgPT4gZnMuZXhpc3RzU3luYyhwYXRoLmpvaW4obW9kdWxlc0RpciwgZGlyLCAncGFja2FnZS5qc29uJykpKVxuICAgICAgICAgICAgLy8gR2VuZXJhdGUgYXJyYXkgb2YgcGFja2FnZSBuYW1lc1xuICAgICAgICAgICAgLm1hcChkaXIgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhY2thZ2VJbmZvID0gSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMocGF0aC5qb2luKG1vZHVsZXNEaXIsIGRpciwgJ3BhY2thZ2UuanNvbicpKSk7XG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgaW5jbHVkZSB0aGVtZSB0eXBlIHBhY2thZ2VzLlxuICAgICAgICAgICAgICAgIGlmKHBhY2thZ2VJbmZvLnNlbmNoYSAmJiBwYWNrYWdlSW5mby5zZW5jaGEudHlwZSAhPT0gJ3RoZW1lJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFja2FnZUluZm8uc2VuY2hhLm5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC8vIFJlbW92ZSBhbnkgdW5kZWZpbmVkcyBmcm9tIG1hcFxuICAgICAgICAgICAgLmZpbHRlcihuYW1lID0+IG5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBhdGggdG8gdGhlIHNlbmNoYSBjbWQgZXhlY3V0YWJsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIF9nZXRTZW5jaENtZFBhdGgoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyB1c2UgQGV4dGpzL3NlbmNoYS1jbWQgZnJvbSBub2RlX21vZHVsZXNcbiAgICAgICAgICAgIHJldHVybiByZXF1aXJlKCdAZXh0anMvc2VuY2hhLWNtZCcpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBhdHRlbXB0IHRvIHVzZSBnbG9iYWxseSBpbnN0YWxsZWQgU2VuY2hhIENtZFxuICAgICAgICAgICAgcmV0dXJuICdzZW5jaGEnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgIC8qKlxuICAgICAqIEJ1aWxkcyBhIG1pbmltYWwgdmVyc2lvbiBvZiB0aGUgRXh0UmVhY3QgZnJhbWV3b3JrIGJhc2VkIG9uIHRoZSBjbGFzc2VzIHVzZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgYnVpbGRcbiAgICAgKiBAcGFyYW0ge01vZHVsZVtdfSBtb2R1bGVzIHdlYnBhY2sgbW9kdWxlc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvdXRwdXQgVGhlIHBhdGggdG8gd2hlcmUgdGhlIGZyYW1ld29yayBidWlsZCBzaG91bGQgYmUgd3JpdHRlblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbdG9vbGtpdD0nbW9kZXJuJ10gXCJtb2Rlcm5cIiBvciBcImNsYXNzaWNcIlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvdXRwdXQgVGhlIHBhdGggdG8gdGhlIGRpcmVjdG9yeSB0byBjcmVhdGUgd2hpY2ggd2lsbCBjb250YWluIHRoZSBqcyBhbmQgY3NzIGJ1bmRsZXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGhlbWUgVGhlIG5hbWUgb2YgdGhlIEV4dFJlYWN0IHRoZW1lIHBhY2thZ2UgdG8gdXNlLCBmb3IgZXhhbXBsZSBcInRoZW1lLW1hdGVyaWFsXCJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBwYWNrYWdlcyBBbiBhcnJheSBvZiBFeHRSZWFjdCBwYWNrYWdlcyB0byBpbmNsdWRlXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gcGFja2FnZURpcnMgRGlyZWN0b3JpZXMgY29udGFpbmluZyBwYWNrYWdlc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IG92ZXJyaWRlcyBBbiBhcnJheSBvZiBsb2NhdGlvbnMgZm9yIG92ZXJyaWRlc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZGsgVGhlIGZ1bGwgcGF0aCB0byB0aGUgRXh0UmVhY3QgU0RLXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYnVpbGRFeHRCdW5kbGUobmFtZSwgbW9kdWxlcywgb3V0cHV0LCB7IHRvb2xraXQ9J21vZGVybicsIHRoZW1lLCBwYWNrYWdlcz1bXSwgcGFja2FnZURpcnM9W10sIHNkaywgb3ZlcnJpZGVzIH0pIHtcbiAgICAgICAgbGV0IHNlbmNoYSA9IHRoaXMuX2dldFNlbmNoQ21kUGF0aCgpO1xuXG4gICAgICAgIHRoZW1lID0gdGhlbWUgfHwgKHRvb2xraXQgPT09ICdjbGFzc2ljJyA/ICd0aGVtZS10cml0b24nIDogJ3RoZW1lLW1hdGVyaWFsJyk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMub25CdWlsZEZhaWwgPSByZWplY3Q7XG4gICAgICAgICAgICB0aGlzLm9uQnVpbGRTdWNjZXNzID0gcmVzb2x2ZTtcblxuICAgICAgICAgICAgY21kRXJyb3JzID0gW107XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IG9uQnVpbGREb25lID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjbWRFcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25CdWlsZEZhaWwobmV3IEVycm9yKGNtZEVycm9ycy5qb2luKFwiXCIpKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkJ1aWxkU3VjY2VzcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmICghd2F0Y2hpbmcpIHtcbiAgICAgICAgICAgICAgICByaW1yYWYob3V0cHV0KTtcbiAgICAgICAgICAgICAgICBta2RpcnAob3V0cHV0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGpzO1xuXG4gICAgICAgICAgICBpZiAodGhpcy50cmVlU2hha2luZykge1xuICAgICAgICAgICAgICAgIGxldCBzdGF0ZW1lbnRzID0gWydFeHQucmVxdWlyZShbXCJFeHQuYXBwLkFwcGxpY2F0aW9uXCIsIFwiRXh0LkNvbXBvbmVudFwiLCBcIkV4dC5XaWRnZXRcIl0pJ107IC8vIGZvciBzb21lIHJlYXNvbiBjb21tYW5kIGRvZXNuJ3QgbG9hZCBjb21wb25lbnQgd2hlbiBvbmx5IHBhbmVsIGlzIHJlcXVpcmVkXG5cbiAgICAgICAgICAgICAgICBpZiAocGFja2FnZXMuaW5kZXhPZigncmVhY3RvcicpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2goJ0V4dC5yZXF1aXJlKFwiRXh0LnJlYWN0b3IuUmVuZGVyZXJDZWxsXCIpJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbW9kdWxlIG9mIG1vZHVsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVwcyA9IHRoaXMuZGVwZW5kZW5jaWVzW21vZHVsZS5yZXNvdXJjZV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXBzKSBzdGF0ZW1lbnRzID0gc3RhdGVtZW50cy5jb25jYXQoZGVwcyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAganMgPSBzdGF0ZW1lbnRzLmpvaW4oJztcXG4nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAganMgPSAnRXh0LnJlcXVpcmUoXCJFeHQuKlwiKSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IG1hbmlmZXN0ID0gcGF0aC5qb2luKG91dHB1dCwgJ21hbmlmZXN0LmpzJyk7XG5cbiAgICAgICAgICAgIC8vIGFkZCBleHQtcmVhY3QvcGFja2FnZXMgYXV0b21hdGljYWxseSBpZiBwcmVzZW50XG4gICAgICAgICAgICBjb25zdCB1c2VyUGFja2FnZXMgPSBwYXRoLmpvaW4oJy4nLCAnZXh0LXJlYWN0JywgJ3BhY2thZ2VzJyk7XG5cbiAgICAgICAgICAgIGlmIChmcy5leGlzdHNTeW5jKHVzZXJQYWNrYWdlcykpIHtcbiAgICAgICAgICAgICAgICBwYWNrYWdlRGlycy5wdXNoKHVzZXJQYWNrYWdlcylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZzLmV4aXN0c1N5bmMocGF0aC5qb2luKHNkaywgJ2V4dCcpKSkge1xuICAgICAgICAgICAgICAgIC8vIGxvY2FsIGNoZWNrb3V0IG9mIHRoZSBTREsgcmVwb1xuICAgICAgICAgICAgICAgIHBhY2thZ2VEaXJzLnB1c2gocGF0aC5qb2luKCdleHQnLCAncGFja2FnZXMnKSk7XG4gICAgICAgICAgICAgICAgc2RrID0gcGF0aC5qb2luKHNkaywgJ2V4dCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXdhdGNoaW5nKSB7XG4gICAgICAgICAgICAgICAgZnMud3JpdGVGaWxlU3luYyhwYXRoLmpvaW4ob3V0cHV0LCAnYnVpbGQueG1sJyksIGJ1aWxkWE1MKHsgY29tcHJlc3M6IHRoaXMucHJvZHVjdGlvbiB9KSwgJ3V0ZjgnKTtcbiAgICAgICAgICAgICAgICBmcy53cml0ZUZpbGVTeW5jKHBhdGguam9pbihvdXRwdXQsICdqc2RvbS1lbnZpcm9ubWVudC5qcycpLCBjcmVhdGVKU0RPTUVudmlyb25tZW50KCksICd1dGY4Jyk7XG4gICAgICAgICAgICAgICAgZnMud3JpdGVGaWxlU3luYyhwYXRoLmpvaW4ob3V0cHV0LCAnYXBwLmpzb24nKSwgY3JlYXRlQXBwSnNvbih7IHRoZW1lLCBwYWNrYWdlcywgdG9vbGtpdCwgb3ZlcnJpZGVzLCBwYWNrYWdlRGlycyB9KSwgJ3V0ZjgnKTtcbiAgICAgICAgICAgICAgICBmcy53cml0ZUZpbGVTeW5jKHBhdGguam9pbihvdXRwdXQsICd3b3Jrc3BhY2UuanNvbicpLCBjcmVhdGVXb3Jrc3BhY2VKc29uKHNkaywgcGFja2FnZURpcnMsIG91dHB1dCksICd1dGY4Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBjbWRSZWJ1aWxkTmVlZGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm1hbmlmZXN0ID09PSBudWxsIHx8IGpzICE9PSB0aGlzLm1hbmlmZXN0KSB7XG4gICAgICAgICAgICAgICAgLy8gT25seSB3cml0ZSBtYW5pZmVzdCBpZiBpdCBkaWZmZXJzIGZyb20gdGhlIGxhc3QgcnVuLiAgVGhpcyBwcmV2ZW50cyB1bm5lY2Vzc2FyeSBjbWQgcmVidWlsZHMuXG4gICAgICAgICAgICAgICAgdGhpcy5tYW5pZmVzdCA9IGpzO1xuICAgICAgICAgICAgICAgIGZzLndyaXRlRmlsZVN5bmMobWFuaWZlc3QsIGpzLCAndXRmOCcpO1xuICAgICAgICAgICAgICAgIGNtZFJlYnVpbGROZWVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBcXG5idWlsZGluZyBFeHRSZWFjdCBidW5kbGU6ICR7bmFtZX0gPT4gJHtvdXRwdXR9YCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLndhdGNoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF3YXRjaGluZykge1xuICAgICAgICAgICAgICAgICAgICB3YXRjaGluZyA9IGdhdGhlckVycm9ycyhmb3JrKHNlbmNoYSwgWydhbnQnLCAnd2F0Y2gnXSwgeyBjd2Q6IG91dHB1dCwgc2lsZW50OiB0cnVlIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgd2F0Y2hpbmcuc3RkZXJyLnBpcGUocHJvY2Vzcy5zdGRlcnIpO1xuICAgICAgICAgICAgICAgICAgICB3YXRjaGluZy5zdGRvdXQucGlwZShwcm9jZXNzLnN0ZG91dCk7XG4gICAgICAgICAgICAgICAgICAgIHdhdGNoaW5nLnN0ZG91dC5vbignZGF0YScsIGRhdGEgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS50b1N0cmluZygpLm1hdGNoKC9XYWl0aW5nIGZvciBjaGFuZ2VzXFwuXFwuXFwuLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkJ1aWxkRG9uZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB3YXRjaGluZy5vbignZXhpdCcsIG9uQnVpbGREb25lKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghY21kUmVidWlsZE5lZWRlZCkgb25CdWlsZERvbmUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnVpbGQgPSBnYXRoZXJFcnJvcnMoZm9yayhzZW5jaGEsIFsnYW50JywgJ2J1aWxkJ10sIHsgY3dkOiBvdXRwdXQsIHNpbGVudDogdHJ1ZSB9KSk7XG4gICAgICAgICAgICAgICAgYnVpbGQuc3Rkb3V0LnBpcGUocHJvY2Vzcy5zdGRvdXQpO1xuICAgICAgICAgICAgICAgIGJ1aWxkLnN0ZGVyci5waXBlKHByb2Nlc3Muc3RkZXJyKTtcbiAgICAgICAgICAgICAgICBidWlsZC5vbignZXhpdCcsIG9uQnVpbGREb25lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuXG4iXX0=