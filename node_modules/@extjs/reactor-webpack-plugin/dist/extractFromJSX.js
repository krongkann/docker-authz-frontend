"use strict";

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _babylon = require('babylon');

var _astTraverse = require('ast-traverse');

var _astTraverse2 = _interopRequireDefault(_astTraverse);

var _babelGenerator = require('babel-generator');

var _babelGenerator2 = _interopRequireDefault(_babelGenerator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MODULE_PATTERN = /^@extjs\/(ext-react.*|reactor\/(classic|modern))$/;

function toXtype(str) {
    return str.toLowerCase().replace(/_/g, '-');
}

/**
 * Extracts Ext.create equivalents from jsx tags so that cmd knows which classes to include in the bundle
 * @param {String} js The javascript code
 * @param {Compilation} compilation The webpack compilation object
 * @returns {Array} An array of Ext.create statements
 */
module.exports = function extractFromJSX(js, compilation, module) {
    var statements = [];
    var types = {};

    // Aliases used for reactify
    var reactifyAliases = new Set([]);

    var ast = (0, _babylon.parse)(js, {
        plugins: ['jsx', 'flow', 'doExpressions', 'objectRestSpread', 'classProperties', 'exportExtensions', 'asyncGenerators', 'functionBind', 'functionSent', 'dynamicImport'],
        sourceType: 'module'
    });

    /**
     * Adds a type mapping for a reactify call
     * @param {String} varName The name of the local variable being defined.
     * @param {Node} reactifyArgNode The argument passed to reactify()
     */
    function addType(varName, reactifyArgNode) {
        if (reactifyArgNode.type === 'StringLiteral') {
            types[varName] = { xtype: toXtype(reactifyArgNode.value) };
        } else {
            types[varName] = { xclass: js.slice(reactifyArgNode.start, reactifyArgNode.end) };
        }
    }

    (0, _astTraverse2.default)(ast, {
        pre: function pre(node) {
            if (node.type == 'ImportDeclaration') {
                if (node.source.value.match(MODULE_PATTERN)) {
                    // look for: import { Grid } from '@extjs/reactor'
                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = undefined;

                    try {
                        for (var _iterator = node.specifiers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                            var spec = _step.value;

                            types[spec.local.name] = { xtype: toXtype(spec.imported.name) };
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return) {
                                _iterator.return();
                            }
                        } finally {
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                } else if (node.source.value === '@extjs/reactor') {
                    // identify local names of reactify based on import { reactify as foo } from '@extjs/reactor';
                    var _iteratorNormalCompletion2 = true;
                    var _didIteratorError2 = false;
                    var _iteratorError2 = undefined;

                    try {
                        for (var _iterator2 = node.specifiers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                            var _spec = _step2.value;

                            if (_spec.imported.name === 'reactify') {
                                reactifyAliases.add(_spec.local.name);
                            }
                        }
                    } catch (err) {
                        _didIteratorError2 = true;
                        _iteratorError2 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion2 && _iterator2.return) {
                                _iterator2.return();
                            }
                        } finally {
                            if (_didIteratorError2) {
                                throw _iteratorError2;
                            }
                        }
                    }
                }
            }

            // Look for reactify calls. Keep track of the names of each component so we can map JSX tags to xtypes and
            // convert props to configs so Sencha Cmd can discover automatic dependencies in the manifest.
            if (node.type == 'VariableDeclarator' && node.init && node.init.type === 'CallExpression' && node.init.callee && reactifyAliases.has(node.init.callee.name)) {
                if (node.id.elements) {
                    // example: const [ Panel, Grid ] = reactify('Panel', 'Grid');
                    for (var i = 0; i < node.id.elements.length; i++) {
                        var tagName = node.id.elements[i].name;
                        if (!tagName) continue;

                        var valueNode = node.init.arguments[i];
                        if (!valueNode) continue;

                        addType(tagName, valueNode);
                    }
                } else {
                    // example: const Grid = reactify('grid');
                    var varName = node.id.name;
                    var arg = node.init.arguments && node.init.arguments[0] && node.init.arguments[0];
                    if (varName && arg) addType(varName, arg);
                }
            }

            // Convert React.createElement(...) calls to the equivalent Ext.create(...) calls to put in the manifest.
            if (node.type === 'CallExpression' && node.callee.object && node.callee.object.name === 'React' && node.callee.property.name === 'createElement') {
                var _node$arguments = _slicedToArray(node.arguments, 2),
                    tag = _node$arguments[0],
                    props = _node$arguments[1];

                var type = types[tag.name];

                if (type) {
                    var config = void 0;

                    if (Array.isArray(props.properties)) {
                        config = (0, _babelGenerator2.default)(props).code;
                        for (var key in type) {
                            config = '{\n  ' + key + ': \'' + type[key] + '\',' + config.slice(1);
                        }
                    } else {
                        config = JSON.stringify(type);
                    }

                    statements.push('Ext.create(' + config + ')');
                }
            }
        }
    });

    // ensure that all imported classes are present in the build even if they aren't used,
    // otherwise the call to reactify will fail
    for (var key in types) {
        statements.push('Ext.create(' + JSON.stringify(types[key]) + ')');
    }

    return statements;
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9leHRyYWN0RnJvbUpTWC5qcyJdLCJuYW1lcyI6WyJNT0RVTEVfUEFUVEVSTiIsInRvWHR5cGUiLCJzdHIiLCJ0b0xvd2VyQ2FzZSIsInJlcGxhY2UiLCJtb2R1bGUiLCJleHBvcnRzIiwiZXh0cmFjdEZyb21KU1giLCJqcyIsImNvbXBpbGF0aW9uIiwic3RhdGVtZW50cyIsInR5cGVzIiwicmVhY3RpZnlBbGlhc2VzIiwiU2V0IiwiYXN0IiwicGx1Z2lucyIsInNvdXJjZVR5cGUiLCJhZGRUeXBlIiwidmFyTmFtZSIsInJlYWN0aWZ5QXJnTm9kZSIsInR5cGUiLCJ4dHlwZSIsInZhbHVlIiwieGNsYXNzIiwic2xpY2UiLCJzdGFydCIsImVuZCIsInByZSIsIm5vZGUiLCJzb3VyY2UiLCJtYXRjaCIsInNwZWNpZmllcnMiLCJzcGVjIiwibG9jYWwiLCJuYW1lIiwiaW1wb3J0ZWQiLCJhZGQiLCJpbml0IiwiY2FsbGVlIiwiaGFzIiwiaWQiLCJlbGVtZW50cyIsImkiLCJsZW5ndGgiLCJ0YWdOYW1lIiwidmFsdWVOb2RlIiwiYXJndW1lbnRzIiwiYXJnIiwib2JqZWN0IiwicHJvcGVydHkiLCJ0YWciLCJwcm9wcyIsImNvbmZpZyIsIkFycmF5IiwiaXNBcnJheSIsInByb3BlcnRpZXMiLCJjb2RlIiwia2V5IiwiSlNPTiIsInN0cmluZ2lmeSIsInB1c2giXSwibWFwcGluZ3MiOiJBQUFBOzs7O0FBRUE7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRUEsSUFBTUEsaUJBQWlCLG1EQUF2Qjs7QUFFQSxTQUFTQyxPQUFULENBQWlCQyxHQUFqQixFQUFzQjtBQUNsQixXQUFPQSxJQUFJQyxXQUFKLEdBQWtCQyxPQUFsQixDQUEwQixJQUExQixFQUFnQyxHQUFoQyxDQUFQO0FBQ0g7O0FBRUQ7Ozs7OztBQU1BQyxPQUFPQyxPQUFQLEdBQWlCLFNBQVNDLGNBQVQsQ0FBd0JDLEVBQXhCLEVBQTRCQyxXQUE1QixFQUF5Q0osTUFBekMsRUFBaUQ7QUFDOUQsUUFB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QXdDTCxPQUFPNUIsS0FBUCxDQUFhLENBQWIsQ0FBeEM7QUFDSDtBQUNKLHFCQUxELE1BS087QUFDSDRCLGlDQUFTTSxLQUFLQyxTQUFMLENBQWV2QyxJQUFmLENBQVQ7QUFDSDs7QUFFRFYsK0JBQVdrRCxJQUFYLGlCQUE4QlIsTUFBOUI7QUFDSDtBQUNKO0FBQ0o7QUE1RFMsS0FBZDs7QUErREE7QUFDQTtBQUNBLFNBQUssSUFBSUssR0FBVCxJQUFnQjlDLEtBQWhCLEVBQXVCO0FBQ25CRCxtQkFBV2tELElBQVgsaUJBQThCRixLQUFLQyxTQUFMLENBQWVoRCxNQUFNOEMsR0FBTixDQUFmLENBQTlCO0FBQ0g7O0FBRUQsV0FBTy9DLFVBQVA7QUFDSCxDQTFHRCIsImZpbGUiOiJleHRyYWN0RnJvbUpTWC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBwYXJzZSB9IGZyb20gJ2JhYnlsb24nO1xuaW1wb3J0IHRyYXZlcnNlIGZyb20gJ2FzdC10cmF2ZXJzZSc7XG5pbXBvcnQgZ2VuZXJhdGUgZnJvbSAnYmFiZWwtZ2VuZXJhdG9yJztcblxuY29uc3QgTU9EVUxFX1BBVFRFUk4gPSAvXkBleHRqc1xcLyhleHQtcmVhY3QuKnxyZWFjdG9yXFwvKGNsYXNzaWN8bW9kZXJuKSkkLztcblxuZnVuY3Rpb24gdG9YdHlwZShzdHIpIHtcbiAgICByZXR1cm4gc3RyLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXy9nLCAnLScpO1xufVxuXG4vKipcbiAqIEV4dHJhY3RzIEV4dC5jcmVhdGUgZXF1aXZhbGVudHMgZnJvbSBqc3ggdGFncyBzbyB0aGF0IGNtZCBrbm93cyB3aGljaCBjbGFzc2VzIHRvIGluY2x1ZGUgaW4gdGhlIGJ1bmRsZVxuICogQHBhcmFtIHtTdHJpbmd9IGpzIFRoZSBqYXZhc2NyaXB0IGNvZGVcbiAqIEBwYXJhbSB7Q29tcGlsYXRpb259IGNvbXBpbGF0aW9uIFRoZSB3ZWJwYWNrIGNvbXBpbGF0aW9uIG9iamVjdFxuICogQHJldHVybnMge0FycmF5fSBBbiBhcnJheSBvZiBFeHQuY3JlYXRlIHN0YXRlbWVudHNcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBleHRyYWN0RnJvbUpTWChqcywgY29tcGlsYXRpb24sIG1vZHVsZSkge1xuICAgIGNvbnN0IHN0YXRlbWVudHMgPSBbXTtcbiAgICBjb25zdCB0eXBlcyA9IHt9O1xuXG4gICAgLy8gQWxpYXNlcyB1c2VkIGZvciByZWFjdGlmeVxuICAgIGNvbnN0IHJlYWN0aWZ5QWxpYXNlcyA9IG5ldyBTZXQoW10pO1xuXG4gICAgY29uc3QgYXN0ID0gcGFyc2UoanMsIHtcbiAgICAgICAgcGx1Z2luczogW1xuICAgICAgICAgICAgJ2pzeCcsXG4gICAgICAgICAgICAnZmxvdycsXG4gICAgICAgICAgICAnZG9FeHByZXNzaW9ucycsXG4gICAgICAgICAgICAnb2JqZWN0UmVzdFNwcmVhZCcsXG4gICAgICAgICAgICAnY2xhc3NQcm9wZXJ0aWVzJyxcbiAgICAgICAgICAgICdleHBvcnRFeHRlbnNpb25zJyxcbiAgICAgICAgICAgICdhc3luY0dlbmVyYXRvcnMnLFxuICAgICAgICAgICAgJ2Z1bmN0aW9uQmluZCcsXG4gICAgICAgICAgICAnZnVuY3Rpb25TZW50JyxcbiAgICAgICAgICAgICdkeW5hbWljSW1wb3J0J1xuICAgICAgICBdLFxuICAgICAgICBzb3VyY2VUeXBlOiAnbW9kdWxlJ1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHR5cGUgbWFwcGluZyBmb3IgYSByZWFjdGlmeSBjYWxsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhck5hbWUgVGhlIG5hbWUgb2YgdGhlIGxvY2FsIHZhcmlhYmxlIGJlaW5nIGRlZmluZWQuXG4gICAgICogQHBhcmFtIHtOb2RlfSByZWFjdGlmeUFyZ05vZGUgVGhlIGFyZ3VtZW50IHBhc3NlZCB0byByZWFjdGlmeSgpXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWRkVHlwZSh2YXJOYW1lLCByZWFjdGlmeUFyZ05vZGUpIHtcbiAgICAgICAgaWYgKHJlYWN0aWZ5QXJnTm9kZS50eXBlID09PSAnU3RyaW5nTGl0ZXJhbCcpIHtcbiAgICAgICAgICAgIHR5cGVzW3Zhck5hbWVdID0geyB4dHlwZTogdG9YdHlwZShyZWFjdGlmeUFyZ05vZGUudmFsdWUpIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0eXBlc1t2YXJOYW1lXSA9IHsgeGNsYXNzOiBqcy5zbGljZShyZWFjdGlmeUFyZ05vZGUuc3RhcnQsIHJlYWN0aWZ5QXJnTm9kZS5lbmQpIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0cmF2ZXJzZShhc3QsIHtcbiAgICAgICAgcHJlOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlID09ICdJbXBvcnREZWNsYXJhdGlvbicpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5zb3VyY2UudmFsdWUubWF0Y2goTU9EVUxFX1BBVFRFUk4pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGxvb2sgZm9yOiBpbXBvcnQgeyBHcmlkIH0gZnJvbSAnQGV4dGpzL3JlYWN0b3InXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHNwZWMgb2Ygbm9kZS5zcGVjaWZpZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlc1tzcGVjLmxvY2FsLm5hbWVdID0geyB4dHlwZTogdG9YdHlwZShzcGVjLmltcG9ydGVkLm5hbWUpIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUuc291cmNlLnZhbHVlID09PSAnQGV4dGpzL3JlYWN0b3InKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlkZW50aWZ5IGxvY2FsIG5hbWVzIG9mIHJlYWN0aWZ5IGJhc2VkIG9uIGltcG9ydCB7IHJlYWN0aWZ5IGFzIGZvbyB9IGZyb20gJ0BleHRqcy9yZWFjdG9yJztcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgc3BlYyBvZiBub2RlLnNwZWNpZmllcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcGVjLmltcG9ydGVkLm5hbWUgPT09ICdyZWFjdGlmeScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFjdGlmeUFsaWFzZXMuYWRkKHNwZWMubG9jYWwubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIExvb2sgZm9yIHJlYWN0aWZ5IGNhbGxzLiBLZWVwIHRyYWNrIG9mIHRoZSBuYW1lcyBvZiBlYWNoIGNvbXBvbmVudCBzbyB3ZSBjYW4gbWFwIEpTWCB0YWdzIHRvIHh0eXBlcyBhbmRcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgcHJvcHMgdG8gY29uZmlncyBzbyBTZW5jaGEgQ21kIGNhbiBkaXNjb3ZlciBhdXRvbWF0aWMgZGVwZW5kZW5jaWVzIGluIHRoZSBtYW5pZmVzdC5cbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT0gJ1ZhcmlhYmxlRGVjbGFyYXRvcicgJiYgbm9kZS5pbml0ICYmIG5vZGUuaW5pdC50eXBlID09PSAnQ2FsbEV4cHJlc3Npb24nICYmIG5vZGUuaW5pdC5jYWxsZWUgJiYgcmVhY3RpZnlBbGlhc2VzLmhhcyhub2RlLmluaXQuY2FsbGVlLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuaWQuZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXhhbXBsZTogY29uc3QgWyBQYW5lbCwgR3JpZCBdID0gcmVhY3RpZnkoJ1BhbmVsJywgJ0dyaWQnKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmlkLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0YWdOYW1lID0gbm9kZS5pZC5lbGVtZW50c1tpXS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0YWdOYW1lKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWVOb2RlID0gbm9kZS5pbml0LmFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWVOb2RlKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkVHlwZSh0YWdOYW1lLCB2YWx1ZU5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXhhbXBsZTogY29uc3QgR3JpZCA9IHJlYWN0aWZ5KCdncmlkJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhck5hbWUgPSBub2RlLmlkLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFyZyA9IG5vZGUuaW5pdC5hcmd1bWVudHMgJiYgbm9kZS5pbml0LmFyZ3VtZW50c1swXSAmJiBub2RlLmluaXQuYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFyTmFtZSAmJiBhcmcpIGFkZFR5cGUodmFyTmFtZSwgYXJnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvbnZlcnQgUmVhY3QuY3JlYXRlRWxlbWVudCguLi4pIGNhbGxzIHRvIHRoZSBlcXVpdmFsZW50IEV4dC5jcmVhdGUoLi4uKSBjYWxscyB0byBwdXQgaW4gdGhlIG1hbmlmZXN0LlxuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ0NhbGxFeHByZXNzaW9uJyAmJiBub2RlLmNhbGxlZS5vYmplY3QgJiYgbm9kZS5jYWxsZWUub2JqZWN0Lm5hbWUgPT09ICdSZWFjdCcgJiYgbm9kZS5jYWxsZWUucHJvcGVydHkubmFtZSA9PT0gJ2NyZWF0ZUVsZW1lbnQnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3RhZywgcHJvcHNdID0gbm9kZS5hcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgbGV0IHR5cGUgPSB0eXBlc1t0YWcubmFtZV07XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29uZmlnO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BzLnByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcgPSBnZW5lcmF0ZShwcm9wcykuY29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiB0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnID0gYHtcXG4gICR7a2V5fTogJyR7dHlwZVtrZXldfScsJHtjb25maWcuc2xpY2UoMSl9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZyA9IEpTT04uc3RyaW5naWZ5KHR5cGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50cy5wdXNoKGBFeHQuY3JlYXRlKCR7Y29uZmlnfSlgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGVuc3VyZSB0aGF0IGFsbCBpbXBvcnRlZCBjbGFzc2VzIGFyZSBwcmVzZW50IGluIHRoZSBidWlsZCBldmVuIGlmIHRoZXkgYXJlbid0IHVzZWQsXG4gICAgLy8gb3RoZXJ3aXNlIHRoZSBjYWxsIHRvIHJlYWN0aWZ5IHdpbGwgZmFpbFxuICAgIGZvciAobGV0IGtleSBpbiB0eXBlcykge1xuICAgICAgICBzdGF0ZW1lbnRzLnB1c2goYEV4dC5jcmVhdGUoJHtKU09OLnN0cmluZ2lmeSh0eXBlc1trZXldKX0pYClcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhdGVtZW50cztcbn07XG4iXX0=